diff --git a/Gemfile b/Gemfile
index 17fb50c..f0bae37 100644
--- a/Gemfile
+++ b/Gemfile
@@ -1,4 +1,6 @@
 source 'https://rubygems.org'
 
+gem 'unleash-engine', path: '../yggdrasil/ruby-engine'
+
 # Specify your gem's dependencies in unleash-client.gemspec
 gemspec
diff --git a/lib/unleash.rb b/lib/unleash.rb
index 9a6f1c7..260cf40 100644
--- a/lib/unleash.rb
+++ b/lib/unleash.rb
@@ -1,6 +1,5 @@
 require 'unleash/version'
 require 'unleash/configuration'
-require 'unleash/strategies'
 require 'unleash/context'
 require 'unleash/client'
 require 'logger'
@@ -9,7 +8,7 @@ module Unleash
   TIME_RESOLUTION = 3
 
   class << self
-    attr_accessor :configuration, :toggle_fetcher, :toggles, :toggle_metrics, :reporter, :segment_cache, :logger
+    attr_accessor :configuration, :toggle_fetcher, :toggles, :toggle_metrics, :reporter, :segment_cache, :logger, :engine
   end
 
   self.configuration = Unleash::Configuration.new
@@ -26,6 +25,6 @@ module Unleash
   end
 
   def self.strategies
-    self.configuration.strategies
+    nil
   end
 end
diff --git a/lib/unleash/activation_strategy.rb b/lib/unleash/activation_strategy.rb
deleted file mode 100644
index 29feb0c..0000000
--- a/lib/unleash/activation_strategy.rb
+++ /dev/null
@@ -1,31 +0,0 @@
-module Unleash
-  class ActivationStrategy
-    attr_accessor :name, :params, :constraints, :disabled
-
-    def initialize(name, params, constraints = [])
-      self.name = name
-      self.disabled = false
-
-      if params.is_a?(Hash)
-        self.params = params
-      elsif params.nil?
-        self.params = {}
-      else
-        Unleash.logger.warn "Invalid params provided for ActivationStrategy (params:#{params})"
-        self.params = {}
-      end
-
-      if constraints.is_a?(Array) && constraints.each{ |c| c.is_a?(Constraint) }
-        self.constraints = constraints
-      else
-        Unleash.logger.warn "Invalid constraints provided for ActivationStrategy (contraints: #{constraints})"
-        self.disabled = true
-        self.constraints = []
-      end
-    end
-
-    def matches_context?(context)
-      self.constraints.any?{ |c| c.matches_context? context }
-    end
-  end
-end
diff --git a/lib/unleash/client.rb b/lib/unleash/client.rb
index 2191caf..4b53300 100644
--- a/lib/unleash/client.rb
+++ b/lib/unleash/client.rb
@@ -17,6 +17,7 @@ module Unleash
 
       Unleash.logger = Unleash.configuration.logger.clone
       Unleash.logger.level = Unleash.configuration.log_level
+      Unleash.engine = UnleashEngine.new
 
       Unleash.toggle_fetcher = Unleash::ToggleFetcher.new
       if Unleash.configuration.disable_client
@@ -40,16 +41,18 @@ module Unleash
                         default_value_param
                       end
 
-      toggle_as_hash = Unleash&.toggles&.select{ |toggle| toggle['name'] == feature }&.first
+      Unleash.logger.debug "Unleash::Client.is_enabled? feature: #{feature} with context #{context}"
 
-      if toggle_as_hash.nil?
+      toggle_enabled = Unleash&.engine&.enabled?(feature, context)
+      if toggle_enabled.nil?
         Unleash.logger.debug "Unleash::Client.is_enabled? feature: #{feature} not found"
+        Unleash&.engine&.count_toggle(feature, false)
         return default_value
       end
 
-      toggle = Unleash::FeatureToggle.new(toggle_as_hash, Unleash&.segment_cache)
+      Unleash&.engine&.count_toggle(feature, toggle_enabled)
 
-      toggle.is_enabled?(context)
+      toggle_enabled
     end
 
     def is_disabled?(feature, context = nil, default_value_param = true, &fallback_blk)
@@ -74,22 +77,20 @@ module Unleash
     def get_variant(feature, context = Unleash::Context.new, fallback_variant = disabled_variant)
       Unleash.logger.debug "Unleash::Client.get_variant for feature: #{feature} with context #{context}"
 
-      toggle_as_hash = Unleash&.toggles&.select{ |toggle| toggle['name'] == feature }&.first
-
-      if toggle_as_hash.nil?
-        Unleash.logger.debug "Unleash::Client.get_variant feature: #{feature} not found"
-        return fallback_variant
+      toggle_enabled = Unleash&.engine&.enabled?(feature, context)
+      if toggle_enabled.nil?
+        Unleash&.engine&.count_toggle(feature, false)
+      else
+        Unleash&.engine&.count_toggle(feature, toggle_enabled)
       end
 
-      toggle = Unleash::FeatureToggle.new(toggle_as_hash)
-      variant = toggle.get_variant(context, fallback_variant)
-
-      if variant.nil?
-        Unleash.logger.debug "Unleash::Client.get_variant variants for feature: #{feature} not found"
+      variant_response = Unleash&.engine.get_variant(feature, context)
+      if variant_response.code < 0
+        Unleash&.engine&.count_variant(feature, fallback_variant.name)
         return fallback_variant
       end
-
-      # TODO: Add to README: name, payload, enabled (bool)
+      variant = variant_response.variant
+      Unleash&.engine&.count_variant(feature, variant.name)
 
       variant
     end
@@ -118,7 +119,7 @@ module Unleash
         'appName': Unleash.configuration.app_name,
         'instanceId': Unleash.configuration.instance_id,
         'sdkVersion': "unleash-client-ruby:" + Unleash::VERSION,
-        'strategies': Unleash.strategies.keys,
+        'strategies': nil,
         'started': Time.now.iso8601(Unleash::TIME_RESOLUTION),
         'interval': Unleash.configuration.metrics_interval_in_millis
       }
@@ -137,7 +138,6 @@ module Unleash
     end
 
     def start_metrics
-      Unleash.toggle_metrics = Unleash::Metrics.new
       Unleash.reporter = Unleash::MetricsReporter.new
       self.metrics_scheduled_executor = Unleash::ScheduledExecutor.new(
         'MetricsReporter',
diff --git a/lib/unleash/configuration.rb b/lib/unleash/configuration.rb
index 4f43200..dddd90f 100644
--- a/lib/unleash/configuration.rb
+++ b/lib/unleash/configuration.rb
@@ -40,9 +40,9 @@ module Unleash
     def validate!
       return if self.disable_client
 
-      raise ArgumentError, "URL and app_name are required parameters." if self.app_name.nil? || self.url.nil?
+      raise ArgumentError, "app_name is a required parameter." if self.app_name.nil?
 
-      validate_custom_http_headers!(self.custom_http_headers)
+      validate_custom_http_headers!(self.custom_http_headers) unless self.url.nil?
     end
 
     def refresh_backup_file!
@@ -96,7 +96,7 @@ module Unleash
       self.backup_file      = nil
       self.log_level        = Logger::WARN
       self.bootstrap_config = nil
-      self.strategies       = Unleash::Strategies.new
+      self.strategies       = nil
 
       self.custom_http_headers = {}
     end
diff --git a/lib/unleash/constraint.rb b/lib/unleash/constraint.rb
deleted file mode 100644
index 51607c1..0000000
--- a/lib/unleash/constraint.rb
+++ /dev/null
@@ -1,115 +0,0 @@
-require 'date'
-module Unleash
-  class Constraint
-    attr_accessor :context_name, :operator, :value, :inverted, :case_insensitive
-
-    OPERATORS = {
-      IN: ->(context_v, constraint_v){ constraint_v.include? context_v.to_s },
-      NOT_IN: ->(context_v, constraint_v){ !constraint_v.include? context_v.to_s },
-      STR_STARTS_WITH: ->(context_v, constraint_v){ constraint_v.any?{ |v| context_v.start_with? v } },
-      STR_ENDS_WITH: ->(context_v, constraint_v){ constraint_v.any?{ |v| context_v.end_with? v } },
-      STR_CONTAINS: ->(context_v, constraint_v){ constraint_v.any?{ |v| context_v.include? v } },
-      NUM_EQ: ->(context_v, constraint_v){ on_valid_float(constraint_v, context_v){ |x, y| (x - y).abs < Float::EPSILON } },
-      NUM_LT: ->(context_v, constraint_v){ on_valid_float(constraint_v, context_v){ |x, y| (x > y) } },
-      NUM_LTE: ->(context_v, constraint_v){ on_valid_float(constraint_v, context_v){ |x, y| (x >= y) } },
-      NUM_GT: ->(context_v, constraint_v){ on_valid_float(constraint_v, context_v){ |x, y| (x < y) } },
-      NUM_GTE: ->(context_v, constraint_v){ on_valid_float(constraint_v, context_v){ |x, y| (x <= y) } },
-      DATE_AFTER: ->(context_v, constraint_v){ on_valid_date(constraint_v, context_v){ |x, y| (x < y) } },
-      DATE_BEFORE: ->(context_v, constraint_v){ on_valid_date(constraint_v, context_v){ |x, y| (x > y) } },
-      SEMVER_EQ: ->(context_v, constraint_v){ on_valid_version(constraint_v, context_v){ |x, y| (x == y) } },
-      SEMVER_GT: ->(context_v, constraint_v){ on_valid_version(constraint_v, context_v){ |x, y| (x < y) } },
-      SEMVER_LT: ->(context_v, constraint_v){ on_valid_version(constraint_v, context_v){ |x, y| (x > y) } },
-      FALLBACK_VALIDATOR: ->(_context_v, _constraint_v){ false }
-    }.freeze
-
-    LIST_OPERATORS = [:IN, :NOT_IN, :STR_STARTS_WITH, :STR_ENDS_WITH, :STR_CONTAINS].freeze
-
-    def initialize(context_name, operator, value = [], inverted: false, case_insensitive: false)
-      raise ArgumentError, "context_name is not a String" unless context_name.is_a?(String)
-
-      unless OPERATORS.include? operator.to_sym
-        Unleash.logger.warn "Operator #{operator} is not a supported operator, " \
-          "falling back to FALLBACK_VALIDATOR which skips this constraint."
-        operator = "FALLBACK_VALIDATOR"
-      end
-      self.log_inconsistent_constraint_configuration(operator.to_sym, value)
-
-      self.context_name = context_name
-      self.operator = operator.to_sym
-      self.value = value
-      self.inverted = !!inverted
-      self.case_insensitive = !!case_insensitive
-    end
-
-    def matches_context?(context)
-      Unleash.logger.debug "Unleash::Constraint matches_context? value: #{self.value} context.get_by_name(#{self.context_name})"
-      return false if context.nil?
-
-      match = matches_constraint?(context)
-      self.inverted ? !match : match
-    rescue KeyError
-      Unleash.logger.warn "Attemped to resolve a context key during constraint resolution: #{self.context_name} but it wasn't \
-      found on the context"
-      false
-    end
-
-    def self.on_valid_date(val1, val2)
-      val1 = DateTime.parse(val1)
-      val2 = DateTime.parse(val2)
-      yield(val1, val2)
-    rescue ArgumentError
-      Unleash.logger.warn "Unleash::ConstraintMatcher unable to parse either context_value (#{val1}) \
-      or constraint_value (#{val2}) into a date. Returning false!"
-      false
-    end
-
-    def self.on_valid_float(val1, val2)
-      val1 = Float(val1)
-      val2 = Float(val2)
-      yield(val1, val2)
-    rescue ArgumentError
-      Unleash.logger.warn "Unleash::ConstraintMatcher unable to parse either context_value (#{val1}) \
-      or constraint_value (#{val2}) into a number. Returning false!"
-      false
-    end
-
-    def self.on_valid_version(val1, val2)
-      val1 = Gem::Version.new(val1)
-      val2 = Gem::Version.new(val2)
-      yield(val1, val2)
-    rescue ArgumentError
-      Unleash.logger.warn "Unleash::ConstraintMatcher unable to parse either context_value (#{val1}) \
-      or constraint_value (#{val2}) into a version. Return false!"
-      false
-    end
-
-    # This should be a private method but for some reason this fails on Ruby 2.5
-    def log_inconsistent_constraint_configuration(operator, value)
-      Unleash.logger.warn "value is a String, operator is expecting an Array" if LIST_OPERATORS.include?(operator) && value.is_a?(String)
-      Unleash.logger.warn "value is an Array, operator is expecting a String" if !LIST_OPERATORS.include?(operator) && value.is_a?(Array)
-    end
-
-    private
-
-    def matches_constraint?(context)
-      Unleash.logger.debug "Unleash::Constraint matches_constraint? value: #{self.value} operator: #{self.operator} " \
-        " context.get_by_name(#{self.context_name})"
-
-      unless OPERATORS.include?(self.operator)
-        Unleash.logger.warn "Invalid constraint operator: #{self.operator}, this should be unreachable. Always returning false."
-        false
-      end
-
-      # when the operator is NOT_IN and there is no data, return true. In all other cases the operator doesn't match.
-      return self.operator == :NOT_IN unless context.include?(self.context_name)
-
-      v = self.value.dup
-      context_value = context.get_by_name(self.context_name)
-
-      v.map!(&:upcase) if self.case_insensitive
-      context_value.upcase! if self.case_insensitive
-
-      OPERATORS[self.operator].call(context_value, v)
-    end
-  end
-end
diff --git a/lib/unleash/context.rb b/lib/unleash/context.rb
index 98ba467..9e235ce 100644
--- a/lib/unleash/context.rb
+++ b/lib/unleash/context.rb
@@ -23,6 +23,22 @@ module Unleash
         ",app_name=#{@app_name},environment=#{@environment}>"
     end
 
+    def as_json
+      {
+        appName: self.app_name,
+        environment: self.environment,
+        userId: self.user_id,
+        sessionId: self.session_id,
+        remoteAddress: self.remote_address,
+        currentTime: self.current_time,
+        properties: self.properties
+      }
+    end
+
+    def to_json(*options)
+      as_json(*options).to_json(*options)
+    end
+
     def to_h
       ATTRS.map{ |attr| [attr, self.send(attr)] }.to_h.merge(properties: @properties)
     end
diff --git a/lib/unleash/feature_toggle.rb b/lib/unleash/feature_toggle.rb
index ec064b3..02020e5 100644
--- a/lib/unleash/feature_toggle.rb
+++ b/lib/unleash/feature_toggle.rb
@@ -1,187 +1,10 @@
-require 'unleash/activation_strategy'
-require 'unleash/constraint'
 require 'unleash/variant_definition'
 require 'unleash/variant'
-require 'unleash/strategy/util'
-require 'securerandom'
 
 module Unleash
   class FeatureToggle
-    attr_accessor :name, :enabled, :strategies, :variant_definitions
-
-    def initialize(params = {}, segment_map = {})
-      params = {} if params.nil?
-
-      self.name       = params.fetch('name', nil)
-      self.enabled    = params.fetch('enabled', false)
-
-      self.strategies = initialize_strategies(params, segment_map)
-      self.variant_definitions = initialize_variant_definitions(params)
-    end
-
-    def to_s
-      "<FeatureToggle: name=#{name},enabled=#{enabled},strategies=#{strategies},variant_definitions=#{variant_definitions}>"
-    end
-
-    def is_enabled?(context)
-      result = am_enabled?(context)
-
-      choice = result ? :yes : :no
-      Unleash.toggle_metrics.increment(name, choice) unless Unleash.configuration.disable_metrics
-
-      result
-    end
-
-    def get_variant(context, fallback_variant = Unleash::FeatureToggle.disabled_variant)
-      raise ArgumentError, "Provided fallback_variant is not of type Unleash::Variant" if fallback_variant.class.name != 'Unleash::Variant'
-
-      context = ensure_valid_context(context)
-
-      toggle_enabled = am_enabled?(context)
-      variant = resolve_variant(context, toggle_enabled)
-
-      choice = toggle_enabled ? :yes : :no
-      Unleash.toggle_metrics.increment_variant(self.name, choice, variant.name) unless Unleash.configuration.disable_metrics
-      variant
-    end
-
     def self.disabled_variant
       Unleash::Variant.new(name: 'disabled', enabled: false)
     end
-
-    private
-
-    def resolve_variant(context, toggle_enabled)
-      return Unleash::FeatureToggle.disabled_variant unless toggle_enabled
-      return Unleash::FeatureToggle.disabled_variant if sum_variant_defs_weights <= 0
-
-      variant_from_override_match(context) || variant_from_weights(context, resolve_stickiness)
-    end
-
-    def resolve_stickiness
-      self.variant_definitions&.map(&:stickiness)&.compact&.first || "default"
-    end
-
-    # only check if it is enabled, do not do metrics
-    def am_enabled?(context)
-      result =
-        if self.enabled
-          self.strategies.empty? ||
-            self.strategies.any? do |s|
-              strategy_enabled?(s, context) && strategy_constraint_matches?(s, context)
-            end
-        else
-          false
-        end
-
-      Unleash.logger.debug "Unleash::FeatureToggle (enabled:#{self.enabled} " \
-        "and Strategies combined with contraints returned #{result})"
-
-      result
-    end
-
-    def strategy_enabled?(strategy, context)
-      r = Unleash.strategies.fetch(strategy.name).is_enabled?(strategy.params, context)
-      Unleash.logger.debug "Unleash::FeatureToggle.strategy_enabled? Strategy #{strategy.name} returned #{r} with context: #{context}"
-      r
-    end
-
-    def strategy_constraint_matches?(strategy, context)
-      return false if strategy.disabled
-
-      strategy.constraints.empty? || strategy.constraints.all?{ |c| c.matches_context?(context) }
-    end
-
-    def sum_variant_defs_weights
-      self.variant_definitions.map(&:weight).reduce(0, :+)
-    end
-
-    def variant_salt(context, stickiness = "default")
-      begin
-        return context.get_by_name(stickiness) if !context.nil? && stickiness != "default"
-      rescue KeyError
-        Unleash.logger.warn "Custom stickiness key (#{stickiness}) not found in the provided context #{context}. " \
-          "Falling back to default behavior."
-      end
-      return context.user_id unless context&.user_id.to_s.empty?
-      return context.session_id unless context&.session_id.to_s.empty?
-      return context.remote_address unless context&.remote_address.to_s.empty?
-
-      SecureRandom.random_number
-    end
-
-    def variant_from_override_match(context)
-      variant = self.variant_definitions.find{ |vd| vd.override_matches_context?(context) }
-      return nil if variant.nil?
-
-      Unleash::Variant.new(name: variant.name, enabled: true, payload: variant.payload)
-    end
-
-    def variant_from_weights(context, stickiness)
-      variant_weight = Unleash::Strategy::Util.get_normalized_number(variant_salt(context, stickiness), self.name, sum_variant_defs_weights)
-      prev_weights = 0
-
-      variant_definition = self.variant_definitions
-        .find do |v|
-          res = (prev_weights + v.weight >= variant_weight)
-          prev_weights += v.weight
-          res
-        end
-      return self.disabled_variant if variant_definition.nil?
-
-      Unleash::Variant.new(name: variant_definition.name, enabled: true, payload: variant_definition.payload)
-    end
-
-    def ensure_valid_context(context)
-      unless ['NilClass', 'Unleash::Context'].include? context.class.name
-        Unleash.logger.error "Provided context is not of the correct type #{context.class.name}, " \
-          "please use Unleash::Context. Context set to nil."
-        context = nil
-      end
-      context
-    end
-
-    def initialize_strategies(params, segment_map)
-      params.fetch('strategies', [])
-        .select{ |s| s.has_key?('name') && Unleash.strategies.includes?(s['name']) }
-        .map do |s|
-          ActivationStrategy.new(
-            s['name'],
-            s['parameters'],
-            resolve_constraints(s, segment_map)
-          )
-        end || []
-    end
-
-    def resolve_constraints(strategy, segment_map)
-      segment_constraints = (strategy["segments"] || []).map do |segment_id|
-        segment_map[segment_id]&.fetch("constraints")
-      end
-      (strategy.fetch("constraints", []) + segment_constraints).flatten.map do |constraint|
-        return nil if constraint.nil?
-
-        Constraint.new(
-          constraint.fetch('contextName'),
-          constraint.fetch('operator'),
-          constraint.fetch('value', nil) || constraint.fetch('values', nil),
-          inverted: constraint.fetch('inverted', false),
-          case_insensitive: constraint.fetch('caseInsensitive', false)
-        )
-      end
-    end
-
-    def initialize_variant_definitions(params)
-      (params.fetch('variants', []) || [])
-        .select{ |v| v.is_a?(Hash) && v.has_key?('name') }
-        .map do |v|
-          VariantDefinition.new(
-            v.fetch('name', ''),
-            v.fetch('weight', 0),
-            v.fetch('payload', nil),
-            v.fetch('stickiness', nil),
-            v.fetch('overrides', [])
-          )
-        end || []
-    end
   end
 end
diff --git a/lib/unleash/metrics.rb b/lib/unleash/metrics.rb
deleted file mode 100644
index 6342ade..0000000
--- a/lib/unleash/metrics.rb
+++ /dev/null
@@ -1,41 +0,0 @@
-module Unleash
-  class Metrics
-    attr_accessor :features, :features_lock
-
-    def initialize
-      self.features = {}
-      self.features_lock = Mutex.new
-    end
-
-    def to_s
-      self.features_lock.synchronize do
-        return self.features.to_json
-      end
-    end
-
-    def increment(feature, choice)
-      raise "InvalidArgument choice must be :yes or :no" unless [:yes, :no].include? choice
-
-      self.features_lock.synchronize do
-        self.features[feature] = { yes: 0, no: 0 } unless self.features.include? feature
-        self.features[feature][choice] += 1
-      end
-    end
-
-    def increment_variant(feature, choice, variant)
-      self.features_lock.synchronize do
-        self.features[feature] = { yes: 0, no: 0 } unless self.features.include? feature
-        self.features[feature][choice] += 1
-        self.features[feature]['variants'] = {}     unless self.features[feature].include? 'variants'
-        self.features[feature]['variants'][variant] = 0 unless self.features[feature]['variants'].include? variant
-        self.features[feature]['variants'][variant] += 1
-      end
-    end
-
-    def reset
-      self.features_lock.synchronize do
-        self.features = {}
-      end
-    end
-  end
-end
diff --git a/lib/unleash/metrics_reporter.rb b/lib/unleash/metrics_reporter.rb
index fc1e7ca..4cd4340 100755
--- a/lib/unleash/metrics_reporter.rb
+++ b/lib/unleash/metrics_reporter.rb
@@ -1,5 +1,4 @@
 require 'unleash/configuration'
-require 'unleash/metrics'
 require 'net/http'
 require 'json'
 require 'time'
@@ -15,22 +14,17 @@ module Unleash
     end
 
     def generate_report
-      now = Time.now
-
-      start = self.last_time
-      stop  = now
-      self.last_time = now
-
+      puts "Making report"
+      metrics = Unleash&.engine&.get_metrics()
+      if metrics.nil? || metrics.empty?
+        puts "nothing here"
+        return nil
+      end
       report = {
         'appName': Unleash.configuration.app_name,
         'instanceId': Unleash.configuration.instance_id,
-        'bucket': {
-          'start': start.iso8601(Unleash::TIME_RESOLUTION),
-          'stop': stop.iso8601(Unleash::TIME_RESOLUTION),
-          'toggles': Unleash.toggle_metrics.features
-        }
+        'bucket': metrics
       }
-      Unleash.toggle_metrics.reset
 
       report
     end
@@ -38,13 +32,14 @@ module Unleash
     def post
       Unleash.logger.debug "post() Report"
 
-      if bucket_empty? && (Time.now - self.last_time < LONGEST_WITHOUT_A_REPORT) # and last time is less then 10 minutes...
+      bucket = self.generate_report
+      if bucket.nil? && (Time.now - self.last_time < LONGEST_WITHOUT_A_REPORT) # and last time is less then 10 minutes...
         Unleash.logger.debug "Report not posted to server, as it would have been empty. (and has been empty for up to 10 min)"
 
         return
       end
 
-      response = Unleash::Util::Http.post(Unleash.configuration.client_metrics_uri, self.generate_report.to_json)
+      response = Unleash::Util::Http.post(Unleash.configuration.client_metrics_uri, bucket.to_json)
 
       if ['200', '202'].include? response.code
         Unleash.logger.debug "Report sent to unleash server successfully. Server responded with http code #{response.code}"
@@ -54,9 +49,5 @@ module Unleash
     end
 
     private
-
-    def bucket_empty?
-      Unleash.toggle_metrics.features.empty?
-    end
   end
 end
diff --git a/lib/unleash/strategies.rb b/lib/unleash/strategies.rb
deleted file mode 100644
index 842af4f..0000000
--- a/lib/unleash/strategies.rb
+++ /dev/null
@@ -1,80 +0,0 @@
-require 'unleash/strategy/base'
-Gem.find_files('unleash/strategy/**/*.rb').each{ |path| require path }
-
-module Unleash
-  class Strategies
-    def initialize
-      @strategies = {}
-      register_strategies
-    end
-
-    def keys
-      @strategies.keys
-    end
-
-    def includes?(name)
-      @strategies.has_key?(name.to_s)
-    end
-
-    def fetch(name)
-      raise Unleash::Strategy::NotImplemented, "Strategy is not implemented" unless (strategy = @strategies[name.to_s])
-
-      strategy
-    end
-
-    def add(strategy)
-      @strategies[strategy.name] = strategy
-    end
-
-    def []=(key, strategy)
-      warn_deprecated_registration(strategy, 'modifying Unleash::STRATEGIES')
-      @strategies[key.to_s] = strategy
-    end
-
-    def [](key)
-      @strategies[key.to_s]
-    end
-
-    def register_strategies
-      register_base_strategies
-      register_custom_strategies
-    end
-
-    protected
-
-    # Deprecated: Use Unleash.configuration to add custom strategies
-    def register_custom_strategies
-      Unleash::Strategy.constants
-        .select{ |c| Unleash::Strategy.const_get(c).is_a? Class }
-        .reject{ |c| ['NotImplemented', 'Base'].include?(c.to_s) } # Reject abstract classes
-        .map{ |c| Object.const_get("Unleash::Strategy::#{c}") }
-        .reject{ |c| DEFAULT_STRATEGIES.include?(c) } # Reject base classes
-        .each do |c|
-        strategy = c.new
-        warn_deprecated_registration(strategy, 'adding custom class into Unleash::Strategy namespace')
-        self.add(strategy)
-      end
-    end
-
-    def register_base_strategies
-      DEFAULT_STRATEGIES.each{ |c| self.add(c.new) }
-    end
-
-    DEFAULT_STRATEGIES = [
-      Unleash::Strategy::ApplicationHostname,
-      Unleash::Strategy::Default,
-      Unleash::Strategy::FlexibleRollout,
-      Unleash::Strategy::GradualRolloutRandom,
-      Unleash::Strategy::GradualRolloutSessionId,
-      Unleash::Strategy::GradualRolloutUserId,
-      Unleash::Strategy::RemoteAddress,
-      Unleash::Strategy::UserWithId
-    ].freeze
-
-    def warn_deprecated_registration(strategy, method)
-      warn "[DEPRECATED] Registering custom Unleash strategy by #{method} is deprecated.
-             Please use Unleash configuration to register custom strategy: " \
-           "`Unleash.configure {|c| c.strategies.add(#{strategy.class.name}.new) }`"
-    end
-  end
-end
diff --git a/lib/unleash/strategy/application_hostname.rb b/lib/unleash/strategy/application_hostname.rb
deleted file mode 100644
index f5fd578..0000000
--- a/lib/unleash/strategy/application_hostname.rb
+++ /dev/null
@@ -1,26 +0,0 @@
-require 'socket'
-
-module Unleash
-  module Strategy
-    class ApplicationHostname < Base
-      attr_accessor :hostname
-
-      PARAM = 'hostnames'.freeze
-
-      def initialize
-        self.hostname = Socket.gethostname || 'undefined'
-      end
-
-      def name
-        'applicationHostname'
-      end
-
-      # need: :params['hostnames']
-      def is_enabled?(params = {}, _context = nil)
-        return false unless params.is_a?(Hash) && params.has_key?(PARAM)
-
-        params[PARAM].split(",").map(&:strip).map(&:downcase).include?(self.hostname)
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/base.rb b/lib/unleash/strategy/base.rb
deleted file mode 100644
index 3e3a0f0..0000000
--- a/lib/unleash/strategy/base.rb
+++ /dev/null
@@ -1,16 +0,0 @@
-module Unleash
-  module Strategy
-    class NotImplemented < RuntimeError
-    end
-
-    class Base
-      def name
-        raise NotImplemented, "Strategy is not implemented"
-      end
-
-      def is_enabled?(_params = {}, _context = nil)
-        raise NotImplemented, "Strategy is not implemented"
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/default.rb b/lib/unleash/strategy/default.rb
deleted file mode 100644
index d22cdbe..0000000
--- a/lib/unleash/strategy/default.rb
+++ /dev/null
@@ -1,13 +0,0 @@
-module Unleash
-  module Strategy
-    class Default < Base
-      def name
-        'default'
-      end
-
-      def is_enabled?(_params = {}, _context = nil)
-        true
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/flexible_rollout.rb b/lib/unleash/strategy/flexible_rollout.rb
deleted file mode 100644
index edb8256..0000000
--- a/lib/unleash/strategy/flexible_rollout.rb
+++ /dev/null
@@ -1,55 +0,0 @@
-require 'unleash/strategy/util'
-
-module Unleash
-  module Strategy
-    class FlexibleRollout < Base
-      def name
-        'flexibleRollout'
-      end
-
-      # need: params['percentage']
-      def is_enabled?(params = {}, context = nil)
-        return false unless params.is_a?(Hash)
-        return false unless context.instance_of?(Unleash::Context)
-
-        stickiness = params.fetch('stickiness', 'default')
-        stickiness_id = resolve_stickiness(stickiness, context)
-
-        begin
-          percentage = Integer(params.fetch('rollout', 0))
-          percentage = 0 if percentage > 100 || percentage.negative?
-        rescue ArgumentError
-          return false
-        end
-
-        group_id = params.fetch('groupId', '')
-        normalized_number = Util.get_normalized_number(stickiness_id, group_id)
-
-        return false if stickiness_id.nil?
-
-        (percentage.positive? && normalized_number <= percentage)
-      end
-
-      private
-
-      def random
-        Random.rand(0..100)
-      end
-
-      def resolve_stickiness(stickiness, context)
-        case stickiness
-        when 'random'
-          random
-        when 'default'
-          context.user_id || context.session_id || random
-        else
-          begin
-            context.get_by_name(stickiness)
-          rescue KeyError
-            nil
-          end
-        end
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/gradual_rollout_random.rb b/lib/unleash/strategy/gradual_rollout_random.rb
deleted file mode 100644
index 61d0784..0000000
--- a/lib/unleash/strategy/gradual_rollout_random.rb
+++ /dev/null
@@ -1,24 +0,0 @@
-require 'unleash/strategy/util'
-
-module Unleash
-  module Strategy
-    class GradualRolloutRandom < Base
-      def name
-        'gradualRolloutRandom'
-      end
-
-      # need: params['percentage']
-      def is_enabled?(params = {}, _context = nil)
-        return false unless params.is_a?(Hash) && params.has_key?('percentage')
-
-        begin
-          percentage = Integer(params['percentage'] || 0)
-        rescue ArgumentError
-          return false
-        end
-
-        (percentage >= Random.rand(1..100))
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/gradual_rollout_sessionid.rb b/lib/unleash/strategy/gradual_rollout_sessionid.rb
deleted file mode 100644
index 0f2a553..0000000
--- a/lib/unleash/strategy/gradual_rollout_sessionid.rb
+++ /dev/null
@@ -1,21 +0,0 @@
-require 'unleash/strategy/util'
-
-module Unleash
-  module Strategy
-    class GradualRolloutSessionId < Base
-      def name
-        'gradualRolloutSessionId'
-      end
-
-      # need: params['percentage'], params['groupId'], context.user_id,
-      def is_enabled?(params = {}, context = nil)
-        return false unless params.is_a?(Hash) && params.has_key?('percentage')
-        return false unless context.instance_of?(Unleash::Context)
-        return false if context.session_id.nil? || context.session_id.empty?
-
-        percentage = Integer(params['percentage'] || 0)
-        (percentage.positive? && Util.get_normalized_number(context.session_id, params['groupId'] || "") <= percentage)
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/gradual_rollout_userid.rb b/lib/unleash/strategy/gradual_rollout_userid.rb
deleted file mode 100644
index 1aa3c05..0000000
--- a/lib/unleash/strategy/gradual_rollout_userid.rb
+++ /dev/null
@@ -1,21 +0,0 @@
-require 'unleash/strategy/util'
-
-module Unleash
-  module Strategy
-    class GradualRolloutUserId < Base
-      def name
-        'gradualRolloutUserId'
-      end
-
-      # need: params['percentage'], params['groupId'], context.user_id,
-      def is_enabled?(params = {}, context = nil, _constraints = [])
-        return false unless params.is_a?(Hash) && params.has_key?('percentage')
-        return false unless context.instance_of?(Unleash::Context)
-        return false if context.user_id.nil? || context.user_id.empty?
-
-        percentage = Integer(params['percentage'] || 0)
-        (percentage.positive? && Util.get_normalized_number(context.user_id, params['groupId'] || "") <= percentage)
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/remote_address.rb b/lib/unleash/strategy/remote_address.rb
deleted file mode 100644
index d222311..0000000
--- a/lib/unleash/strategy/remote_address.rb
+++ /dev/null
@@ -1,36 +0,0 @@
-module Unleash
-  module Strategy
-    class RemoteAddress < Base
-      PARAM = 'IPs'.freeze
-
-      def name
-        'remoteAddress'
-      end
-
-      # need: params['IPs'], context.remote_address
-      def is_enabled?(params = {}, context = nil)
-        return false unless params.is_a?(Hash) && params.has_key?(PARAM)
-        return false unless params.fetch(PARAM, nil).is_a? String
-        return false unless context.instance_of?(Unleash::Context)
-
-        remote_address = ipaddr_or_nil_from_str(context.remote_address)
-
-        params[PARAM]
-          .split(',')
-          .map(&:strip)
-          .map{ |ipblock| ipaddr_or_nil_from_str(ipblock) }
-          .compact
-          .map{ |ipb| ipb.include? remote_address }
-          .any?
-      end
-
-      private
-
-      def ipaddr_or_nil_from_str(ip)
-        IPAddr.new(ip)
-      rescue StandardError
-        nil
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/user_with_id.rb b/lib/unleash/strategy/user_with_id.rb
deleted file mode 100644
index c20a75b..0000000
--- a/lib/unleash/strategy/user_with_id.rb
+++ /dev/null
@@ -1,20 +0,0 @@
-module Unleash
-  module Strategy
-    class UserWithId < Base
-      PARAM = 'userIds'.freeze
-
-      def name
-        'userWithId'
-      end
-
-      # requires: params['userIds'], context.user_id,
-      def is_enabled?(params = {}, context = nil)
-        return false unless params.is_a?(Hash) && params.has_key?(PARAM)
-        return false unless params.fetch(PARAM, nil).is_a? String
-        return false unless context.instance_of?(Unleash::Context)
-
-        params[PARAM].split(",").map(&:strip).include?(context.user_id)
-      end
-    end
-  end
-end
diff --git a/lib/unleash/strategy/util.rb b/lib/unleash/strategy/util.rb
deleted file mode 100644
index a00ade8..0000000
--- a/lib/unleash/strategy/util.rb
+++ /dev/null
@@ -1,16 +0,0 @@
-require 'murmurhash3'
-
-module Unleash
-  module Strategy
-    module Util
-      module_function
-
-      NORMALIZER = 100
-
-      # convert the two strings () into a number between 1 and base (100 by default)
-      def get_normalized_number(identifier, group_id, base = NORMALIZER)
-        MurmurHash3::V32.str_hash("#{group_id}:#{identifier}") % base + 1
-      end
-    end
-  end
-end
diff --git a/lib/unleash/toggle_fetcher.rb b/lib/unleash/toggle_fetcher.rb
index 2b33f4d..41361ef 100755
--- a/lib/unleash/toggle_fetcher.rb
+++ b/lib/unleash/toggle_fetcher.rb
@@ -2,14 +2,14 @@ require 'unleash/configuration'
 require 'unleash/bootstrap/handler'
 require 'net/http'
 require 'json'
+require 'unleash_engine'
 
 module Unleash
   class ToggleFetcher
-    attr_accessor :toggle_cache, :toggle_lock, :toggle_resource, :etag, :retry_count, :segment_cache
+    attr_accessor :toggle_engine, :toggle_lock, :toggle_resource, :etag, :retry_count, :segment_cache
 
     def initialize
       self.etag = nil
-      self.toggle_cache = nil
       self.segment_cache = nil
       self.toggle_lock = Mutex.new
       self.toggle_resource = ConditionVariable.new
@@ -35,8 +35,8 @@ module Unleash
     def toggles
       self.toggle_lock.synchronize do
         # wait for resource, only if it is null
-        self.toggle_resource.wait(self.toggle_lock) if self.toggle_cache.nil?
-        return self.toggle_cache
+        self.toggle_resource.wait(self.toggle_lock) if self.toggle_engine.nil?
+        return self.toggle_engine
       end
     end
 
@@ -55,16 +55,16 @@ module Unleash
       end
 
       self.etag = response['ETag']
-      features = get_features(response.body)
+      engine = get_engine(response.body)
 
       # always synchronize with the local cache when fetching:
-      synchronize_with_local_cache!(features)
+      synchronize_with_local_cache!(engine)
 
       update_running_client!
-      save!
+      save! response.body
     end
 
-    def save!
+    def save!(toggle_data)
       Unleash.logger.debug "Will save toggles to disk now"
 
       backup_file = Unleash.configuration.backup_file
@@ -72,7 +72,7 @@ module Unleash
 
       self.toggle_lock.synchronize do
         File.open(backup_file_tmp, "w") do |file|
-          file.write(self.toggle_cache.to_json)
+          file.write(toggle_data)
         end
         File.rename(backup_file_tmp, backup_file)
       end
@@ -84,10 +84,10 @@ module Unleash
 
     private
 
-    def synchronize_with_local_cache!(features)
-      if self.toggle_cache != features
+    def synchronize_with_local_cache!(engine)
+      if self.toggle_engine != engine
         self.toggle_lock.synchronize do
-          self.toggle_cache = features
+          self.toggle_engine = engine
         end
 
         # notify all threads waiting for this resource to no longer wait
@@ -96,10 +96,8 @@ module Unleash
     end
 
     def update_running_client!
-      if Unleash.toggles != self.toggles["features"] || Unleash.segment_cache != self.toggles["segments"]
-        Unleash.logger.info "Updating toggles to main client, there has been a change in the server."
-        Unleash.toggles = self.toggles["features"]
-        Unleash.segment_cache = self.toggles["segments"]
+      if Unleash.engine != self.toggle_engine
+        Unleash.engine = self.toggle_engine
       end
     end
 
@@ -121,7 +119,7 @@ module Unleash
 
     def bootstrap
       bootstrap_payload = Unleash::Bootstrap::Handler.new(Unleash.configuration.bootstrap_config).retrieve_toggles
-      synchronize_with_local_cache! get_features bootstrap_payload
+      synchronize_with_local_cache! get_engine bootstrap_payload
       update_running_client!
 
       # reset Unleash.configuration.bootstrap_data to free up memory, as we will never use it again
@@ -134,10 +132,15 @@ module Unleash
       segments_array.map{ |segment| [segment["id"], segment] }.to_h
     end
 
+    def get_engine(response_body)
+      engine = UnleashEngine.new
+      engine.take_state(response_body)
+      engine
+    end
+
     # @param response_body [String]
     def get_features(response_body)
       response_hash = JSON.parse(response_body)
-
       if response_hash['version'] >= 1
         return { "features" => response_hash["features"], "segments" => build_segment_map(response_hash["segments"]) }
       end
diff --git a/spec/unleash/activation_strategy_spec.rb b/spec/unleash/activation_strategy_spec.rb
deleted file mode 100644
index 812dbe0..0000000
--- a/spec/unleash/activation_strategy_spec.rb
+++ /dev/null
@@ -1,42 +0,0 @@
-require 'unleash/constraint'
-
-RSpec.describe Unleash::ActivationStrategy do
-  before do
-    Unleash.configuration = Unleash::Configuration.new
-    Unleash.logger = Unleash.configuration.logger
-  end
-
-  let(:name) { 'test name' }
-
-  describe '#initialize' do
-    context 'with correct payload' do
-      let(:params) { Hash.new(test: true) }
-      let(:constraints) { [Unleash::Constraint.new("constraint_name", "IN", ["value"])] }
-
-      it 'initializes with correct attributes' do
-        expect(Unleash.logger).to_not receive(:warn)
-
-        strategy = Unleash::ActivationStrategy.new(name, params, constraints)
-
-        expect(strategy.name).to eq name
-        expect(strategy.params).to eq params
-        expect(strategy.constraints).to eq constraints
-      end
-    end
-
-    context 'with incorrect payload' do
-      let(:params) { 'bad_params' }
-      let(:constraints) { [] }
-
-      it 'initializes with correct attributes and logs warning' do
-        expect(Unleash.logger).to receive(:warn)
-
-        strategy = Unleash::ActivationStrategy.new(name, params, constraints)
-
-        expect(strategy.name).to eq name
-        expect(strategy.params).to eq({})
-        expect(strategy.constraints).to eq(constraints)
-      end
-    end
-  end
-end
diff --git a/spec/unleash/client_specification_spec.rb b/spec/unleash/client_specification_spec.rb
index 621ed4f..a45ffbe 100644
--- a/spec/unleash/client_specification_spec.rb
+++ b/spec/unleash/client_specification_spec.rb
@@ -10,37 +10,30 @@ RSpec.describe Unleash::Client do
   DEFAULT_VARIANT = Unleash::Variant.new(name: 'unknown', enabled: false).freeze
 
   before do
-    Unleash.configuration = Unleash::Configuration.new
     Unleash.logger = Unleash.configuration.logger
     Unleash.logger.level = Unleash.configuration.log_level
-    Unleash.toggles = []
-    Unleash.toggle_metrics = {}
-
-    # Do not test metrics:
-    Unleash.configuration.disable_metrics = true
   end
 
   if File.exist?(SPECIFICATION_PATH + '/index.json')
     JSON.parse(File.read(SPECIFICATION_PATH + '/index.json')).each do |test_file|
       describe "for #{test_file}" do
         current_test_set = JSON.parse(File.read(SPECIFICATION_PATH + '/' + test_file))
+
         context "with #{current_test_set.fetch('name')} " do
-          # name = current_test_set.fetch('name', '')
           tests = current_test_set.fetch('tests', [])
           state = current_test_set.fetch('state', {})
-          state_features = state.fetch('features', [])
-          state_segments = state.fetch('segments', []).map{ |segment| [segment["id"], segment] }.to_h
-
-          let(:unleash_toggles) { state_features }
-
           tests.each do |test|
             it "test that #{test['description']}" do
-              test_toggle = unleash_toggles.select{ |t| t.fetch('name', '') == test.fetch('toggleName') }.first
-
-              toggle = Unleash::FeatureToggle.new(test_toggle, state_segments)
               context = Unleash::Context.new(test['context'])
 
-              toggle_result = toggle.is_enabled?(context)
+              unleash = Unleash::Client.new(
+                app_name: 'bootstrap-test',
+                instance_id: 'local-test-cli',
+                disable_client: true,
+                disable_metrics: true,
+                bootstrap_config: Unleash::Bootstrap::Configuration.new(data: current_test_set.fetch('state', {}).to_json)
+              )
+              toggle_result = unleash.is_enabled?(test.fetch('toggleName'), context)
 
               expect(toggle_result).to eq(test['expectedResult'])
             end
@@ -49,14 +42,21 @@ RSpec.describe Unleash::Client do
           variant_tests = current_test_set.fetch('variantTests', [])
           variant_tests.each do |test|
             it "test that #{test['description']}" do
-              test_toggle = unleash_toggles.select{ |t| t.fetch('name', '') == test.fetch('toggleName') }.first
-
-              toggle = Unleash::FeatureToggle.new(test_toggle, state_segments)
               context = Unleash::Context.new(test['context'])
 
-              variant = toggle.get_variant(context, DEFAULT_VARIANT)
+              unleash = Unleash::Client.new(
+                app_name: 'bootstrap-test',
+                instance_id: 'local-test-cli',
+                disable_client: true,
+                disable_metrics: true,
+                bootstrap_config: Unleash::Bootstrap::Configuration.new(data: current_test_set.fetch('state', {}).to_json)
+              )
+              variant = unleash.get_variant(test.fetch('toggleName'), context)
+              expectedResult = test['expectedResult']
 
-              expect(variant).to eq(Unleash::Variant.new(test['expectedResult']))
+              expect(variant.name).to eq(expectedResult['name'])
+              expect(variant.enabled).to eq(expectedResult['enabled'])
+              expect(variant.payload).to eq(expectedResult['payload'])
             end
           end
         end
diff --git a/spec/unleash/constraint_spec.rb b/spec/unleash/constraint_spec.rb
deleted file mode 100644
index 38c1909..0000000
--- a/spec/unleash/constraint_spec.rb
+++ /dev/null
@@ -1,458 +0,0 @@
-RSpec.describe Unleash::Constraint do
-  before do
-    Unleash.configuration = Unleash::Configuration.new
-    Unleash.logger = Unleash.configuration.logger
-  end
-
-  describe '#is_enabled?' do
-    it 'matches based on property IN value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: 'dev'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'IN', ['dev'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'IN', ['dev', 'pre'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'NOT_IN', ['dev', 'pre'])
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('env', 'NOT_IN', ['pre', 'prod'])
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property NOT_IN value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.2',
-        properties: {
-          env: 'dev'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'NOT_IN', ['dev'])
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('env', 'NOT_IN', ['dev', 'pre'])
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('env', 'NOT_IN', ['pre', 'prod'])
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on a value NOT_IN in a not existing context field' do
-      context_params = {
-        properties: {}
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'NOT_IN', ['anything'])
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on user_id IN/NOT_IN user_id' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.3',
-        properties: {
-          fancy: 'polarbear'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('user_id', 'IN', ['123', '456'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('user_id', 'IN', ['456', '789'])
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('user_id', 'NOT_IN', ['123', '456'])
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('user_id', 'NOT_IN', ['456', '789'])
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on user_id IN/NOT_IN user_id with user_id as int' do
-      context_params = {
-        user_id: 123
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('user_id', 'IN', ['123', '456'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('user_id', 'IN', ['456', '789'])
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('user_id', 'NOT_IN', ['123', '456'])
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('user_id', 'NOT_IN', ['456', '789'])
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property STR_STARTS_WITH value' do
-      context_params = {
-        properties: {
-          env: 'development'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'STR_STARTS_WITH', ['dev'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_STARTS_WITH', ['development'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_STARTS_WITH', ['ment'])
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'matches based on property STR_ENDS_WITH value' do
-      context_params = {
-        properties: {
-          env: 'development'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'STR_ENDS_WITH', ['ment'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_ENDS_WITH', ['development'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_ENDS_WITH', ['dev'])
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'matches based on property STR_CONTAINS value' do
-      context_params = {
-        properties: {
-          env: 'development'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'STR_CONTAINS', ['ment'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_CONTAINS', ['dev'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_CONTAINS', ['development'])
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_CONTAINS', ['DEVELOPMENT'])
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'matches based on property NUM_EQ value' do
-      context_params = {
-        properties: {
-          distance: '0.3'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('distance', 'NUM_EQ', '0.3')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_EQ', '0.2')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_EQ', (0.1 + 0.2).to_s)
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property NUM_LT value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          distance: '3.141'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_LT', '2.718')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_LT', '3.141')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_LT', '6.282')
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property NUM_LTE value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          distance: '3.141'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_LTE', '2.718')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_LTE', '3.141')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_LTE', '6.282')
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property NUM_GT value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          distance: '3.141'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_GT', '2.718')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_GT', '3.141')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_GT', '6.282')
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'matches based on property NUM_GTE value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          distance: '3.141'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_GTE', '2.718')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_GTE', '3.141')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('distance', 'NUM_GTE', '6.282')
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'matches based on property SEMVER_EQ value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: '3.1.41-beta'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('env', 'SEMVER_EQ', '3.1.41-beta')
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property SEMVER_GT value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: '3.1.41-gamma'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('env', 'SEMVER_GT', '3.1.41-beta')
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property SEMVER_LT value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: '3.1.41-alpha'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('env', 'SEMVER_LT', '3.1.41-beta')
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on property DATE_AFTER value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        currentTime: '2022-01-30T13:00:00.000Z'
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-29T13:00:00.000Z')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-29T13:00:00Z')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-29T13:00Z')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-30T12:59:59.999999Z')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-30T12:59:59.999Z')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-30T12:59:59')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-30T12:59')
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-30T13:00:00.000Z')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_AFTER', '2022-01-31T13:00:00.000Z')
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'matches based on property DATE_BEFORE value' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        currentTime: '2022-01-30T13:00:00.000Z'
-      }
-      context = Unleash::Context.new(context_params)
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_BEFORE', '2022-01-29T13:00:00.000Z')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('currentTime', 'DATE_BEFORE', '2022-01-31T13:00:00.000Z')
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on case insensitive property when operator is uppercased' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: 'development'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'STR_STARTS_WITH', ['DEV'], case_insensitive: true)
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_ENDS_WITH', ['MENT'], case_insensitive: true)
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_CONTAINS', ['LOP'], case_insensitive: true)
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on case insensitive property when context is uppercased' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: 'DEVELOPMENT'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'STR_STARTS_WITH', ['dev'], case_insensitive: true)
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_ENDS_WITH', ['ment'], case_insensitive: true)
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'STR_CONTAINS', ['lop'], case_insensitive: true)
-      expect(constraint.matches_context?(context)).to be true
-    end
-
-    it 'matches based on inverted property' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: 'development'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'STR_STARTS_WITH', ['dev'], inverted: true)
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('env', 'STR_ENDS_WITH', ['ment'], inverted: true)
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('env', 'STR_CONTAINS', ['lop'], inverted: true)
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'gracefully handles invalid constraint operators' do
-      context_params = {
-        user_id: '123',
-        session_id: 'verylongsesssionid',
-        remote_address: '127.0.0.1',
-        properties: {
-          env: 'development'
-        }
-      }
-      context = Unleash::Context.new(context_params)
-      constraint = Unleash::Constraint.new('env', 'NOT_A_VALID_OPERATOR', 'dev', inverted: true)
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'NOT_A_VALID_OPERATOR', ['dev'], inverted: true)
-      expect(constraint.matches_context?(context)).to be true
-
-      constraint = Unleash::Constraint.new('env', 'NOT_A_VALID_OPERATOR', 'dev')
-      expect(constraint.matches_context?(context)).to be false
-
-      constraint = Unleash::Constraint.new('env', 'NOT_A_VALID_OPERATOR', ['dev'])
-      expect(constraint.matches_context?(context)).to be false
-    end
-
-    it 'warns about constraint construction for invalid value types for operator' do
-      array_constraints = ['STR_CONTAINS', 'STR_ENDS_WITH', 'STR_STARTS_WITH', 'IN', 'NOT_IN']
-
-      array_constraints.each do |operator_name|
-        expect(Unleash.logger).to receive(:warn).with("value is a String, operator is expecting an Array")
-        Unleash::Constraint.new('env', operator_name, '')
-      end
-
-      string_constraints = ['NUM_EQ', 'NUM_GT', 'NUM_GTE', 'NUM_LT', 'NUM_LTE',
-                            'DATE_AFTER', 'DATE_BEFORE', 'SEMVER_EQ', 'SEMVER_GT', 'SEMVER_LT']
-      string_constraints.each do |operator_name|
-        expect(Unleash.logger).to receive(:warn).with("value is an Array, operator is expecting a String")
-        Unleash::Constraint.new('env', operator_name, [])
-      end
-    end
-  end
-
-  it 'does resolves to false rather than crashing when passed a nil context' do
-    constraint = Unleash::Constraint.new('anything', 'NUM_GTE', '6.282')
-    expect(constraint.matches_context?(nil)).to be false
-  end
-end
diff --git a/spec/unleash/feature_toggle_spec.rb b/spec/unleash/feature_toggle_spec.rb
deleted file mode 100644
index a95f243..0000000
--- a/spec/unleash/feature_toggle_spec.rb
+++ /dev/null
@@ -1,663 +0,0 @@
-require 'logger'
-require 'unleash'
-require 'unleash/configuration'
-require 'unleash/context'
-require 'unleash/feature_toggle'
-require 'unleash/variant'
-
-RSpec.describe Unleash::FeatureToggle do
-  before do
-    Unleash.configuration = Unleash::Configuration.new
-    Unleash.logger = Unleash.configuration.logger
-    Unleash.logger.level = Unleash.configuration.log_level
-    Unleash.logger.level = Logger::ERROR
-    Unleash.toggles = []
-    Unleash.toggle_metrics = {}
-
-    # Do not test metrics:
-    Unleash.configuration.disable_metrics = true
-  end
-
-  describe 'FeatureToggle with empty strategies' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "test",
-        "enabled" => true,
-        "strategies" => [],
-        "variants" => nil
-      )
-    end
-
-    it 'should return true if enabled' do
-      context = Unleash::Context.new(user_id: 1)
-      expect(feature_toggle.is_enabled?(context)).to be_truthy
-    end
-  end
-
-  describe 'FeatureToggle with empty strategies and disabled toggle' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.userid",
-        "description" => nil,
-        "enabled" => false,
-        "strategies" => [],
-        "variants" => nil,
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-
-    it 'should return false if disabled' do
-      context = Unleash::Context.new(user_id: 1)
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-  end
-
-  describe 'FeatureToggle with userId strategy and enabled toggle' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.userid",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          {
-            "name" => "userWithId",
-            "parameters" => {
-              "userIds" => "12345"
-            }
-          }
-        ],
-        "variants" => nil,
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-
-    it 'should return true if enabled and user_id is matched' do
-      context = Unleash::Context.new(user_id: "12345")
-      expect(feature_toggle.is_enabled?(context)).to be_truthy
-    end
-
-    it 'should return false if enabled and user_id is unmatched' do
-      context = Unleash::Context.new(user_id: "54321")
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-  end
-
-  describe 'FeatureToggle with userId strategy and disabled toggle' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.userid",
-        "description" => nil,
-        "enabled" => false,
-        "strategies" => [
-          {
-            "name" => "userWithId",
-            "parameters" => {
-              "userIds" => "12345"
-            }
-          }
-        ],
-        "variants" => nil,
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-
-    it 'should return false if disabled and user_id matched' do
-      context = Unleash::Context.new(user_id: "12345")
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-
-    it 'should return false if disabled and user_id unmatched' do
-      context = Unleash::Context.new(user_id: "54321")
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-  end
-
-  describe 'FeatureToggle with variants' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.variants",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          {
-            "name" => "default"
-          }
-        ],
-        "variants" => [
-          {
-            "name" => "variant1",
-            "weight" => 50,
-            "stickiness" => "default"
-          },
-          {
-            "name" => "variant2",
-            "weight" => 50,
-            "stickiness" => "default"
-          }
-        ],
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-
-    let(:default_variant) { Unleash::Variant.new(name: 'unknown', default: true) }
-
-    it 'should return variant1 for user_id:1' do
-      context = Unleash::Context.new(user_id: 10)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "variant1",
-        enabled: true,
-        payload: nil
-      )
-    end
-
-    it 'should return variant2 for user_id:2' do
-      context = Unleash::Context.new(user_id: 2)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "variant2",
-        enabled: true,
-        payload: nil
-      )
-    end
-
-    xit 'should return false if default is false.' do
-      context = Unleash::Context.new(user_id: 2)
-      expect(feature_toggle.get_variant(context, default_variant)).to be_falsey
-    end
-  end
-
-  describe 'FeatureToggle including weightless variants' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.variants",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          {
-            "name" => "default"
-          }
-        ],
-        "variants" => [
-          {
-            "name" => "variantA",
-            "weight" => 0,
-            "stickiness" => "default"
-          },
-          {
-            "name" => "variantB",
-            "weight" => 10,
-            "stickiness" => "default"
-          },
-          {
-            "name" => "variantC",
-            "weight" => 20,
-            "stickiness" => "default"
-          }
-        ],
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-
-    let(:default_variant) { Unleash::Variant.new(name: 'unknown', default: true) }
-
-    it 'should return variantC for user_id:1' do
-      context = Unleash::Context.new(user_id: 10)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "variantC",
-        enabled: true,
-        payload: nil
-      )
-    end
-
-    it 'should return variantB for user_id:2' do
-      context = Unleash::Context.new(user_id: 2)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "variantB",
-        enabled: true,
-        payload: nil
-      )
-    end
-  end
-
-  describe 'FeatureToggle with variants which have all zero weight' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.variants",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          {
-            "name" => "default"
-          }
-        ],
-        "variants" => [
-          {
-            "name" => "variantA",
-            "weight" => 0
-          },
-          {
-            "name" => "variantB",
-            "weight" => 0
-          }
-        ],
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-    let(:default_variant) { Unleash::Variant.new(name: 'unknown', default: true) }
-
-    it 'should return disabled for user_id:1' do
-      context = Unleash::Context.new(user_id: 10)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "disabled",
-        enabled: false,
-        payload: nil
-      )
-    end
-
-    it 'should return disabled for user_id:2' do
-      context = Unleash::Context.new(user_id: 2)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "disabled",
-        enabled: false,
-        payload: nil
-      )
-    end
-  end
-
-  describe 'FeatureToggle with variants that have a variant override' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.variants",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          {
-            "name" => "default"
-          }
-        ],
-        "variants" => [
-          {
-            "name" => "variant1",
-            "weight" => 50,
-            "stickiness" => "default",
-            "payload" => {
-              "type" => "string",
-              "value" => "val1"
-            },
-            "overrides" => [{
-              "contextName" => "userId",
-              "values" => ["132", "61"]
-            }]
-          },
-          {
-            "name" => "variant2",
-            "weight" => 50,
-            "stickiness" => "default",
-            "payload" => {
-              "type" => "string",
-              "value" => "val2"
-            }
-          }
-        ],
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-
-    it 'should return variant1 for user_id:61 from override' do
-      context = Unleash::Context.new(user_id: 61)
-      expect(feature_toggle.get_variant(context)).to have_attributes(
-        name: "variant1",
-        enabled: true,
-        payload: { "type" => "string", "value" => "val1" }
-      )
-    end
-
-    it 'should return variant1 for user_id:132 from override' do
-      context = Unleash::Context.new("userId" => 132)
-      expect(feature_toggle.get_variant(context)).to have_attributes(
-        name: "variant1",
-        enabled: true,
-        payload: { "type" => "string", "value" => "val1" }
-      )
-    end
-
-    it 'should return variant2 for user_id:60' do
-      context = Unleash::Context.new(user_id: 60)
-      expect(feature_toggle.get_variant(context)).to have_attributes(
-        name: "variant2",
-        enabled: true,
-        payload: { "type" => "string", "value" => "val2" }
-      )
-    end
-
-    it 'get_variant_with_matching_override should for user_id:61' do
-      # NOTE: Use send method, as we are testing a private method
-      context = Unleash::Context.new(user_id: 61)
-      expect(feature_toggle.send(:variant_from_override_match, context)).to have_attributes(
-        name: "variant1",
-        payload: { "type" => "string", "value" => "val1" }
-      )
-    end
-  end
-
-  describe 'FeatureToggle with no variants' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.variants",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          {
-            "name" => "default"
-          }
-        ],
-        "variants" => [],
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-    let(:default_variant) { Unleash::Variant.new(name: 'unknown', default: true) }
-
-    it 'should return disabled for user_id:1' do
-      context = Unleash::Context.new(user_id: 10)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "disabled",
-        enabled: false,
-        payload: nil
-      )
-    end
-
-    it 'should return disabled for user_id:2' do
-      context = Unleash::Context.new(user_id: 2)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "disabled",
-        enabled: false,
-        payload: nil
-      )
-    end
-
-    it 'should return an enabled fallback when the fallback is specified' do
-      context = Unleash::Context.new(user_id: 2)
-      expect(feature_toggle.get_variant(context, default_variant)).to have_attributes(
-        name: "disabled",
-        enabled: false,
-        payload: nil
-      )
-    end
-  end
-
-  describe 'FeatureToggle with invalid default_variant' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.variants",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          {
-            "name" => "default"
-          }
-        ],
-        "variants" => [],
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-    let(:valid_default_variant) { Unleash::Variant.new(name: 'unknown', default: true) }
-    let(:invalid_default_variant) { Hash.new(name: 'unknown', default: true) }
-
-    it 'should raise an error for an invalid fallback variant' do
-      expect{ feature_toggle.get_variant(nil, invalid_default_variant) }.to raise_error(ArgumentError)
-    end
-
-    it 'should not raise an error for a valid fallback variant' do
-      expect{ feature_toggle.get_variant(nil, valid_default_variant) }.to_not raise_error
-    end
-  end
-
-  describe 'FeatureToggle default Strategy with two constraints' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Test.userid",
-        "description" => "Play with strategy constraints",
-        "enabled" => true,
-        "strategies" => [
-          {
-            "constraints" => [
-              {
-                "contextName" => "environment",
-                "operator" => "IN",
-                "values" => [
-                  "dev"
-                ]
-              },
-              {
-                "contextName" => "userId",
-                "operator" => "IN",
-                "values" => ["123"]
-              }
-            ],
-            "name" => "default",
-            "parameters" => {}
-          }
-        ]
-      )
-    end
-
-    it 'should return true if it matches all constraints' do
-      context = Unleash::Context.new(user_id: "123", environment: "dev")
-      expect(feature_toggle.is_enabled?(context)).to be_truthy
-    end
-
-    it 'should return false if it does not match all constraints (env)' do
-      context = Unleash::Context.new(user_id: "123", environment: "prod")
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-
-    it 'should return false if it does not match all constraints (user_id)' do
-      context = Unleash::Context.new(user_id: "11", environment: "dev")
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-
-    it 'should return false if it does not match any constraint (env and user_id)' do
-      context = Unleash::Context.new(user_id: "11", environment: "prod")
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-  end
-
-  describe 'FeatureToggle default Strategy with one constraint' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "Demo",
-        "description" => "Play with strategy constraints",
-        "enabled" => true,
-        "strategies" => [
-          {
-            "constraints" => [
-              {
-                "contextName" => "environment",
-                "operator" => "IN",
-                "values" => [
-                  "dev"
-                ]
-              }
-            ],
-            "name" => "default",
-            "parameters" => {}
-          }
-        ]
-      )
-    end
-
-    it 'should return true if it matches the constraint' do
-      context = Unleash::Context.new(user_id: "123", environment: "dev")
-      expect(feature_toggle.is_enabled?(context)).to be_truthy
-    end
-
-    it 'should return false if it does not match the constraint' do
-      context = Unleash::Context.new(user_id: "123", environment: "prod")
-      expect(feature_toggle.is_enabled?(context)).to be_falsey
-    end
-  end
-
-  describe 'disabled_variant' do
-    it 'returns disabled variant' do
-      ret = described_class.disabled_variant
-      expect(ret.enabled).to be false
-      expect(ret.name).to eq 'disabled'
-    end
-  end
-
-  describe 'FeatureToggle variant with custom stickiness' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "toggleName",
-        "description" => nil,
-        "enabled" => true,
-        "variants" => [
-          {
-            "name" => "variant1",
-            "weight" => 25,
-            "stickiness" => "organization"
-          },
-          {
-            "name" => "variant2",
-            "weight" => 25,
-            "stickiness" => "organization"
-          },
-          {
-            "name" => "variant3",
-            "weight" => 25,
-            "stickiness" => "organization"
-          },
-          {
-            "name" => "variant4",
-            "weight" => 25,
-            "stickiness" => "organization"
-          }
-
-        ],
-        "createdAt" => "2019-01-24T10:41:45.236Z"
-      )
-    end
-
-    it 'should return variant1 organization 726' do
-      context = Unleash::Context.new(
-        properties: {
-          organization: '726'
-        }
-      )
-
-      expect(feature_toggle.get_variant(context)).to have_attributes(
-        name: "variant1",
-        enabled: true
-      )
-    end
-
-    it 'should return variant2 organization 48' do
-      context = Unleash::Context.new(
-        properties: {
-          organization: '48'
-        }
-      )
-
-      expect(feature_toggle.get_variant(context)).to have_attributes(
-        name: "variant2",
-        enabled: true
-      )
-    end
-
-    it 'should return variant3 organization 381' do
-      context = Unleash::Context.new(
-        properties: {
-          organization: '381'
-        }
-      )
-
-      expect(feature_toggle.get_variant(context)).to have_attributes(
-        name: "variant3",
-        enabled: true
-      )
-    end
-
-    it 'should return variant4 organization 222' do
-      context = Unleash::Context.new(
-        properties: {
-          organization: '222'
-        }
-      )
-
-      expect(feature_toggle.get_variant(context)).to have_attributes(
-        name: "variant4",
-        enabled: true
-      )
-    end
-
-    it 'should work with a nil context' do
-      variant = feature_toggle.get_variant(nil)
-
-      expect(variant.name).to match(/variant\d/)
-      expect(variant.enabled).to be true
-      expect(variant).to be_a_kind_of(Unleash::Variant)
-    end
-  end
-
-  describe 'FeatureToggle Variant with payload and custom stickiness' do
-    let(:feature_toggle) do
-      Unleash::FeatureToggle.new(
-        "name" => "featureVariantX",
-        "description" => nil,
-        "enabled" => true,
-        "strategies" => [
-          { "name" => "default" }
-        ],
-        "variants" => [
-          {
-            "name" => "default-value",
-            "payload" => {
-              "type" => "string",
-              "value" => "payloadData"
-            },
-            "stickiness" => "custom_context_attribute",
-            "weight" => 100,
-            "weightType" => "variable"
-          }
-        ]
-      )
-    end
-
-    let(:expected_variant) do
-      {
-        name: "default-value",
-        enabled: true,
-        payload: {
-          "type" => "string",
-          "value" => "payloadData"
-        }
-      }
-    end
-
-    it 'should return the one variant, when the context correctly contains the custom stickiness parameter' do
-      context = Unleash::Context.new(
-        properties: {
-          default: 'foo',
-          custom_context_attribute: 'uniqueContextValue'
-        }
-      )
-      expect(feature_toggle.get_variant(context)).to have_attributes(expected_variant)
-    end
-
-    it 'should return the one variant, with context that is nil' do
-      expect(feature_toggle.get_variant(nil)).to have_attributes(expected_variant)
-    end
-
-    it 'should return the one variant, even when the contexts do not contain the stickiness parameter' do
-      [
-        nil,
-        Unleash::Context.new,
-        Unleash::Context.new(user_id: '123'),
-        Unleash::Context.new(session_id: '123'),
-        Unleash::Context.new(remote_address: '127.0.0.1'),
-        Unleash::Context.new(properties: { not_custom_context_attribute: 'foo' })
-      ].each do |context|
-        expect(feature_toggle.get_variant(context)).to have_attributes(expected_variant)
-      end
-    end
-  end
-end
diff --git a/spec/unleash/metrics_reporter_spec.rb b/spec/unleash/metrics_reporter_spec.rb
index cd5bd4f..858a0fb 100644
--- a/spec/unleash/metrics_reporter_spec.rb
+++ b/spec/unleash/metrics_reporter_spec.rb
@@ -27,24 +27,26 @@ RSpec.describe Unleash::MetricsReporter do
       config.instance_id = 'rspec/test'
       config.disable_client = true
     end
-    Unleash.toggle_metrics = Unleash::Metrics.new
+    Unleash.engine = UnleashEngine.new
 
-    Unleash.toggle_metrics.increment('featureA', :yes)
-    Unleash.toggle_metrics.increment('featureA', :yes)
-    Unleash.toggle_metrics.increment('featureA', :yes)
-    Unleash.toggle_metrics.increment('featureA', :no)
-    Unleash.toggle_metrics.increment('featureA', :no)
-    Unleash.toggle_metrics.increment('featureB', :yes)
+    Unleash.engine.count_toggle('featureA', true)
+    Unleash.engine.count_toggle('featureA', true)
+    Unleash.engine.count_toggle('featureA', true)
+    Unleash.engine.count_toggle('featureA', false)
+    Unleash.engine.count_toggle('featureA', false)
+    Unleash.engine.count_toggle('featureB', true)
 
     report = metrics_reporter.generate_report
     expect(report[:bucket][:toggles]).to include(
-      "featureA" => {
+      :featureA => {
         no: 2,
-        yes: 3
+        yes: 3,
+        variants: {}
       },
-      "featureB" => {
+      :featureB => {
         no: 0,
-        yes: 1
+        yes: 1,
+        variants: {}
       }
     )
 
@@ -74,14 +76,14 @@ RSpec.describe Unleash::MetricsReporter do
       )
       .to_return(status: 200, body: "", headers: {})
 
-    Unleash.toggle_metrics = Unleash::Metrics.new
+    Unleash.engine = UnleashEngine.new
 
-    Unleash.toggle_metrics.increment('featureA', :yes)
-    Unleash.toggle_metrics.increment('featureA', :yes)
-    Unleash.toggle_metrics.increment('featureA', :yes)
-    Unleash.toggle_metrics.increment('featureA', :no)
-    Unleash.toggle_metrics.increment('featureA', :no)
-    Unleash.toggle_metrics.increment('featureB', :yes)
+    Unleash.engine.count_toggle('featureA', true)
+    Unleash.engine.count_toggle('featureA', true)
+    Unleash.engine.count_toggle('featureA', true)
+    Unleash.engine.count_toggle('featureA', false)
+    Unleash.engine.count_toggle('featureA', false)
+    Unleash.engine.count_toggle('featureB', true)
 
     metrics_reporter.post
 
@@ -105,7 +107,7 @@ RSpec.describe Unleash::MetricsReporter do
   end
 
   it "does not send a report, if there were no metrics registered/evaluated" do
-    Unleash.toggle_metrics = Unleash::Metrics.new
+    Unleash.engine = UnleashEngine.new
 
     metrics_reporter.post
 
diff --git a/spec/unleash/metrics_spec.rb b/spec/unleash/metrics_spec.rb
deleted file mode 100644
index 2830f9b..0000000
--- a/spec/unleash/metrics_spec.rb
+++ /dev/null
@@ -1,72 +0,0 @@
-require "rspec/json_expectations"
-
-RSpec.describe Unleash::Metrics do
-  let(:metrics) { Unleash::Metrics.new }
-
-  it "counts up correctly" do
-    metrics.increment('featureA', :yes)
-    metrics.increment('featureA', :yes)
-    metrics.increment('featureA', :yes)
-    metrics.increment('featureA', :no)
-    metrics.increment('featureA', :no)
-
-    metrics.increment('featureB', :yes)
-    metrics.increment('featureB', :no)
-    metrics.increment('featureC', :no)
-
-    expect(metrics.features['featureA'][:yes]).to eq(3)
-    expect(metrics.features['featureA'][:no]).to  eq(2)
-    expect(metrics.features['featureB'][:yes]).to eq(1)
-    expect(metrics.features['featureB'][:no]).to  eq(1)
-    expect(metrics.features['featureC'][:yes]).to eq(0)
-    expect(metrics.features['featureC'][:no]).to  eq(1)
-  end
-
-  it "resets correctly" do
-    metrics = Unleash::Metrics.new
-
-    metrics.increment('featureA', :yes)
-    metrics.reset
-    metrics.increment('featureB', :no)
-
-    expect(metrics.features['featureA']).to be_nil
-    expect(metrics.features['featureB'][:yes]).to eq(0)
-    expect(metrics.features['featureB'][:no]).to eq(1)
-  end
-
-  it "spits out correct JSON" do
-    metrics.reset
-    metrics.increment('featureA', :yes)
-    metrics.increment('featureB', :no)
-
-    expect(metrics.to_s).to include_json(
-      featureA: {
-        yes: 1,
-        no: 0
-      },
-      featureB: {
-        no: 1
-      }
-    )
-  end
-
-  describe "when dealing with variants" do
-    it "counts up correctly" do
-      metrics.increment_variant('featureA', :yes, 'variantA')
-      metrics.increment_variant('featureA', :yes, 'variantA')
-      metrics.increment_variant('featureA', :yes, 'variantB')
-
-      expect(metrics.features['featureA'][:yes]).to eq(3)
-      expect(metrics.features['featureA'][:no]).to eq(0)
-      expect(metrics.features['featureA']['variants']['variantA']).to eq(2)
-      expect(metrics.features['featureA']['variants']['variantB']).to eq(1)
-    end
-  end
-
-  it "increments feature toggle counter when variant is resolved" do
-    metrics.increment_variant('featureA', :yes, 'variantA')
-
-    expect(metrics.features['featureA'][:yes]).to eq(1)
-    expect(metrics.features['featureA'][:no]).to eq(0)
-  end
-end
diff --git a/spec/unleash/strategies_spec.rb b/spec/unleash/strategies_spec.rb
deleted file mode 100644
index 87b70ff..0000000
--- a/spec/unleash/strategies_spec.rb
+++ /dev/null
@@ -1,156 +0,0 @@
-require "spec_helper"
-
-RSpec.describe Unleash::Strategies do
-  let(:strategies) { described_class.new }
-
-  # Silence warnings we are triggering in this test
-  around do |example|
-    old_verbose = $VERBOSE
-    $VERBOSE = nil
-    example.run
-  ensure
-    $VERBOSE = old_verbose
-  end
-
-  describe 'strategies registration' do
-    let(:default_strategies) do
-      ['applicationHostname', 'default', 'flexibleRollout', 'gradualRolloutRandom',
-       'gradualRolloutSessionId', 'gradualRolloutUserId', 'remoteAddress',
-       'userWithId']
-    end
-
-    context 'when no custom strategies are defined' do
-      it 'has default list' do
-        expect(strategies.keys.sort).to eq(default_strategies)
-      end
-    end
-
-    # This block testing previous way of loading strategies, when we dynamically picked up all classes
-    # defined under `Unleash::Strategy` module
-    context 'when custom strategy is defined' do
-      let(:custom_strategy) do
-        Class.new do
-          def name
-            'myCustomStrategy'
-          end
-        end
-      end
-
-      before do
-        # Define custom class
-        Unleash::Strategy.const_set("MyCustomStrategy", custom_strategy)
-      end
-
-      after do
-        # Remove custom class so it does not interfere with other tests
-        Unleash::Strategy.send(:remove_const, :MyCustomStrategy)
-      end
-
-      it 'includes custom strategy in default list' do
-        expect(strategies.keys.sort).to eq(default_strategies.concat(['myCustomStrategy']).sort)
-      end
-
-      it 'warns about deprecated functionality' do
-        allow(strategies).to receive(:warn)
-        strategies.send(:register_strategies)
-        message = '[DEPRECATED] Registering custom Unleash strategy by adding custom class into Unleash::Strategy'
-        expect(strategies).to have_received(:warn).with(start_with(message))
-      end
-    end
-  end
-
-  describe '#includes?' do
-    it 'returns true for available strategy' do
-      expect(strategies.includes?('gradualRolloutRandom')).to be_truthy
-      expect(strategies.includes?(:userWithId)).to be_truthy
-    end
-
-    it 'returns false for missing strategy' do
-      expect(strategies.includes?(:missing)).to be_falsey
-    end
-  end
-
-  describe '#fetch' do
-    it 'returns available strategy' do
-      expect(strategies.fetch(:flexibleRollout)).to be_instance_of(Unleash::Strategy::FlexibleRollout)
-      expect(strategies.fetch('applicationHostname')).to be_instance_of(Unleash::Strategy::ApplicationHostname)
-    end
-
-    it 'raising error when missing' do
-      message = 'Strategy is not implemented'
-      expect { strategies.fetch(:missing) }.to raise_error(Unleash::Strategy::NotImplemented, message)
-    end
-  end
-
-  describe '#[]' do
-    it 'returns available strategy' do
-      expect(strategies[:flexibleRollout]).to be_instance_of(Unleash::Strategy::FlexibleRollout)
-      expect(strategies['applicationHostname']).to be_instance_of(Unleash::Strategy::ApplicationHostname)
-    end
-
-    it 'returns nil when missing strategy' do
-      expect(strategies[:missing]).to be_nil
-    end
-  end
-
-  describe '#add' do
-    before do
-      strategies.add(custom_strategy)
-    end
-
-    context 'when existing strategy is available' do
-      let(:custom_strategy) { instance_double(Unleash::Strategy::Base, name: 'applicationHostname') }
-
-      it 'overrides previous strategy strategy' do
-        expect(strategies.includes?('applicationHostname')).to be_truthy
-        expect(strategies.fetch(:applicationHostname)).to eq(custom_strategy)
-        expect(strategies.fetch('applicationHostname')).to eq(custom_strategy)
-      end
-    end
-
-    context 'when strategy is new' do
-      let(:custom_strategy) { instance_double(Unleash::Strategy::Base, name: 'test') }
-
-      it 'adds new strategy strategy' do
-        expect(strategies.includes?('test')).to be_truthy
-        expect(strategies.fetch(:test)).to eq(custom_strategy)
-        expect(strategies.fetch('test')).to eq(custom_strategy)
-      end
-    end
-  end
-
-  describe '#[]=' do
-    let(:custom_strategy) { instance_double(Unleash::Strategy::Base, name: 'strange name') }
-
-    context 'when existing strategy is available' do
-      let(:custom_strategy) { instance_double(Unleash::Strategy::Base, name: 'applicationHostname') }
-
-      it 'overrides previous strategy strategy' do
-        strategies[:applicationHostname] = custom_strategy
-
-        expect(strategies.includes?('applicationHostname')).to be_truthy
-        expect(strategies.fetch(:applicationHostname)).to eq(custom_strategy)
-        expect(strategies.fetch('applicationHostname')).to eq(custom_strategy)
-      end
-
-      it 'warns when using this method' do
-        allow(strategies).to receive(:warn)
-        strategies[:applicationHostname] = custom_strategy
-        message = '[DEPRECATED] Registering custom Unleash strategy by modifying Unleash::STRATEGIES'
-        expect(strategies).to have_received(:warn).with(start_with(message))
-      end
-    end
-
-    context 'when strategy is new' do
-      before do
-        strategies['test'] = custom_strategy
-      end
-
-      it 'adds new strategy strategy' do
-        expect(strategies.includes?('test')).to be_truthy
-        expect(strategies.fetch(:test)).to eq(custom_strategy)
-        expect(strategies.fetch('test')).to eq(custom_strategy)
-      end
-    end
-  end
-end
diff --git a/spec/unleash/strategy/application_hostname_spec.rb b/spec/unleash/strategy/application_hostname_spec.rb
deleted file mode 100644
index 0614533..0000000
--- a/spec/unleash/strategy/application_hostname_spec.rb
+++ /dev/null
@@ -1,29 +0,0 @@
-require "unleash/strategy/application_hostname"
-
-RSpec.describe Unleash::Strategy::ApplicationHostname do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::ApplicationHostname.new }
-
-    before do
-      expect(Socket).to receive(:gethostname).and_return("rspechost")
-    end
-
-    it 'correctly initialize' do
-      expect(strategy.hostname).to eq("rspechost")
-    end
-
-    it 'should be enabled with correct params' do
-      expect(strategy.is_enabled?({ 'hostnames' => 'foo,rspechost,bar' })).to be_truthy
-    end
-
-    it 'should be disabled with false params' do
-      expect(strategy.is_enabled?({ 'hostnames' => 'abc,localhost' })).to be_falsey
-    end
-
-    it 'should be disabled on invalid params' do
-      expect(strategy.is_enabled?(nil)).to be_falsey
-      expect(strategy.is_enabled?('string')).to be_falsey
-      expect(strategy.is_enabled?({})).to be_falsey
-    end
-  end
-end
diff --git a/spec/unleash/strategy/base_spec.rb b/spec/unleash/strategy/base_spec.rb
deleted file mode 100644
index 3e04cde..0000000
--- a/spec/unleash/strategy/base_spec.rb
+++ /dev/null
@@ -1,11 +0,0 @@
-require "unleash/strategy/base"
-
-RSpec.describe Unleash::Strategy::Base do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::Base.new }
-
-    it 'raise exception' do
-      expect{ strategy.is_enabled? }.to raise_exception Unleash::Strategy::NotImplemented
-    end
-  end
-end
diff --git a/spec/unleash/strategy/default_spec.rb b/spec/unleash/strategy/default_spec.rb
deleted file mode 100644
index 60a908b..0000000
--- a/spec/unleash/strategy/default_spec.rb
+++ /dev/null
@@ -1,11 +0,0 @@
-require "unleash/strategy/default"
-
-RSpec.describe Unleash::Strategy::Default do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::Default.new }
-
-    it 'always returns true' do
-      expect(strategy.is_enabled?).to be_truthy
-    end
-  end
-end
diff --git a/spec/unleash/strategy/flexible_rollout_spec.rb b/spec/unleash/strategy/flexible_rollout_spec.rb
deleted file mode 100644
index d4783b8..0000000
--- a/spec/unleash/strategy/flexible_rollout_spec.rb
+++ /dev/null
@@ -1,64 +0,0 @@
-require 'unleash/strategy/flexible_rollout'
-
-RSpec.describe Unleash::Strategy::FlexibleRollout do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::FlexibleRollout.new }
-    let(:unleash_context) { Unleash::Context.new }
-
-    it 'should always be enabled when rollout is set to 100, disabled when set to 0' do
-      params = {
-        'groupId' => 'Demo',
-        'rollout' => 100,
-        'stickiness' => 'default'
-      }
-
-      expect(strategy.is_enabled?(params, unleash_context)).to be_truthy
-      expect(strategy.is_enabled?(params.merge({ 'rollout' => 0 }), unleash_context)).to be_falsey
-    end
-
-    it 'should behave predictably when based on the normalized_number' do
-      allow(Unleash::Strategy::Util).to receive(:get_normalized_number).and_return(15)
-
-      params = {
-        'groupId' => 'Demo',
-        'stickiness' => 'default'
-      }
-
-      expect(strategy.is_enabled?(params.merge({ 'rollout' => 14 }), unleash_context)).to be_falsey
-      expect(strategy.is_enabled?(params.merge({ 'rollout' => 15 }), unleash_context)).to be_truthy
-      expect(strategy.is_enabled?(params.merge({ 'rollout' => 16 }), unleash_context)).to be_truthy
-    end
-
-    it 'should be enabled when stickiness=customerId and customerId=61 and rollout=10' do
-      params = {
-        'groupId' => 'Demo',
-        'rollout' => 10,
-        'stickiness' => 'customerId'
-      }
-
-      custom_context = Unleash::Context.new(
-        properties: {
-          customer_id: '61'
-        }
-      )
-
-      expect(strategy.is_enabled?(params, custom_context)).to be_truthy
-    end
-
-    it 'should be disabled when stickiness=customerId and customerId=63 and rollout=10' do
-      params = {
-        'groupId' => 'Demo',
-        'rollout' => 10,
-        'stickiness' => 'customerId'
-      }
-
-      custom_context = Unleash::Context.new(
-        properties: {
-          customer_id: '63'
-        }
-      )
-
-      expect(strategy.is_enabled?(params, custom_context)).to be_falsey
-    end
-  end
-end
diff --git a/spec/unleash/strategy/gradual_rollout_random_spec.rb b/spec/unleash/strategy/gradual_rollout_random_spec.rb
deleted file mode 100644
index c7ab26b..0000000
--- a/spec/unleash/strategy/gradual_rollout_random_spec.rb
+++ /dev/null
@@ -1,32 +0,0 @@
-require "unleash/strategy/gradual_rollout_random"
-
-RSpec.describe Unleash::Strategy::GradualRolloutRandom do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::GradualRolloutRandom.new }
-
-    before do
-      # Random.rand always returns 15, so it is not really random in our tests.
-      allow(Random).to receive(:rand).and_return(15)
-    end
-
-    it 'return true when percentage set (20) is over the returned random value (15)' do
-      expect(strategy.is_enabled?({ 'percentage' => '20' })).to be_truthy
-      expect(strategy.is_enabled?({ 'percentage' => 20 })).to   be_truthy
-      expect(strategy.is_enabled?({ 'percentage' => 20.0 })).to be_truthy
-    end
-
-    it 'return false when percentage set (10) is under the returned random value (15)' do
-      expect(strategy.is_enabled?({ 'percentage' => '10' })).to be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => 10 })).to   be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => 10.0 })).to be_falsey
-    end
-
-    it 'return false when percentage is invalid' do
-      expect(strategy.is_enabled?({ 'percentage' => -1 })).to be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => nil })).to be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => 'abc' })).to be_falsey
-      expect(strategy.is_enabled?('text')).to be_falsey
-      expect(strategy.is_enabled?(nil)).to be_falsey
-    end
-  end
-end
diff --git a/spec/unleash/strategy/gradual_rollout_sessionid_spec.rb b/spec/unleash/strategy/gradual_rollout_sessionid_spec.rb
deleted file mode 100644
index b3d76f3..0000000
--- a/spec/unleash/strategy/gradual_rollout_sessionid_spec.rb
+++ /dev/null
@@ -1,22 +0,0 @@
-require "unleash/strategy/gradual_rollout_sessionid"
-require "unleash/strategy/util"
-
-RSpec.describe Unleash::Strategy::GradualRolloutSessionId do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::GradualRolloutSessionId.new }
-    let(:unleash_context) { Unleash::Context.new(session_id: 'secretsessionidhashgoeshere') }
-    let(:percentage) { Unleash::Strategy::Util.get_normalized_number(unleash_context.session_id, "") }
-
-    it 'return true when percentage set is gt the number returned by the hash function' do
-      expect(strategy.is_enabled?({ 'percentage' => (percentage + 1).to_s }, unleash_context)).to be_truthy
-      expect(strategy.is_enabled?({ 'percentage' => percentage + 1 },   unleash_context)).to be_truthy
-      expect(strategy.is_enabled?({ 'percentage' => percentage + 0.1 }, unleash_context)).to be_truthy
-    end
-
-    it 'return false when percentage set is lt the number returned by the hash function' do
-      expect(strategy.is_enabled?({ 'percentage' => (percentage - 1).to_s }, unleash_context)).to be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => percentage - 1 },   unleash_context)).to be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => percentage - 0.1 }, unleash_context)).to be_falsey
-    end
-  end
-end
diff --git a/spec/unleash/strategy/gradual_rollout_userid_spec.rb b/spec/unleash/strategy/gradual_rollout_userid_spec.rb
deleted file mode 100644
index 2ed9613..0000000
--- a/spec/unleash/strategy/gradual_rollout_userid_spec.rb
+++ /dev/null
@@ -1,21 +0,0 @@
-require "unleash/strategy/gradual_rollout_userid"
-
-RSpec.describe Unleash::Strategy::GradualRolloutUserId do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::GradualRolloutUserId.new }
-    let(:unleash_context) { Unleash::Context.new({ 'userId' => 'alice' }) }
-    let(:percentage) { Unleash::Strategy::Util.get_normalized_number(unleash_context.user_id, "") }
-
-    it 'return true when percentage set is gt the number returned by the hash function' do
-      expect(strategy.is_enabled?({ 'percentage' => (percentage + 1).to_s }, unleash_context)).to be_truthy
-      expect(strategy.is_enabled?({ 'percentage' => percentage + 1 },   unleash_context)).to be_truthy
-      expect(strategy.is_enabled?({ 'percentage' => percentage + 0.1 }, unleash_context)).to be_truthy
-    end
-
-    it 'return false when percentage set is lt the number returned by the hash function' do
-      expect(strategy.is_enabled?({ 'percentage' => (percentage - 1).to_s }, unleash_context)).to be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => percentage - 1 },   unleash_context)).to be_falsey
-      expect(strategy.is_enabled?({ 'percentage' => percentage - 0.1 }, unleash_context)).to be_falsey
-    end
-  end
-end
diff --git a/spec/unleash/strategy/remote_address_spec.rb b/spec/unleash/strategy/remote_address_spec.rb
deleted file mode 100644
index ac3da10..0000000
--- a/spec/unleash/strategy/remote_address_spec.rb
+++ /dev/null
@@ -1,79 +0,0 @@
-require "unleash/strategy/remote_address"
-
-RSpec.describe Unleash::Strategy::RemoteAddress do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::RemoteAddress.new }
-    let(:unleash_context) { Unleash::Context.new({ 'remoteAddress' => '127.0.0.1' }) }
-
-    def context_for_addr(remote_address)
-      Unleash::Context.new(remote_address: remote_address)
-    end
-
-    it 'should be enabled with correct params' do
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.0.1,127.0.0.1,172.12.0.1' }, unleash_context)).to be_truthy
-
-      unleash_context2 = Unleash::Context.new
-      unleash_context2.remote_address = '172.12.0.1'
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.0.1,127.0.0.1,172.12.0.1' }, unleash_context2)).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.0.1,  172.12.0.1 , 127.0.0.1' }, unleash_context2)).to be_truthy
-    end
-
-    it 'should work with ipv6' do
-      ips_and_cidrs = '2001:0db8:85a3:0000:0000:8a2e:0370:7300/120,2001:0db8:85a3:0000:0000:8a2e:0370:7520/123'
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:72ff'))).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:7330'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:7334'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:73ff'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:7400'))).to be_falsey
-
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:7519'))).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:7520'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:753f'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, context_for_addr('2001:0db8:85a3:0000:0000:8a2e:0370:7540'))).to be_falsey
-    end
-
-    it 'should be enabled with correct CIDR params' do
-      ips_and_cidrs = '192.168.0.0/24,127.0.0.1/32,172.12.0.1'
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, unleash_context)).to be_truthy
-
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '172.12.0.1'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '127.0.0.1'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '127.0.0.1/32'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '192.168.0.0'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '192.168.0.1'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '192.168.0.255'))).to be_truthy
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '192.168.0.192/30'))).to be_truthy
-
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '127.0.0.2'))).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '192.168.1.0'))).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => ips_and_cidrs }, Unleash::Context.new(remote_address: '192.168.1.255'))).to be_falsey
-    end
-
-    it 'should be disabled with false params' do
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.0.1,172.12.0.1' }, unleash_context)).to be_falsey
-    end
-
-    it 'should be disabled on invalid params' do
-      expect(strategy.is_enabled?({ 'ips' => '192.168.0.1,172.12.0.1' }, unleash_context)).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => nil }, unleash_context)).to be_falsey
-      expect(strategy.is_enabled?({}, unleash_context)).to be_falsey
-      expect(strategy.is_enabled?('IPs_list', unleash_context)).to be_falsey
-    end
-
-    it 'should be disabled on invalid contexts' do
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.0.1,127.0.0.1,172.12.0.1' }, Unleash::Context.new)).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.0.1,127.0.0.1,172.12.0.1' }, nil)).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.0.1,127.0.0.1,172.12.0.1' })).to be_falsey
-
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.x.y,127.0.0.1' }, Unleash::Context.new(remote_address: '192.168.x.y'))).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => 'foobar,abc/32' }, Unleash::Context.new(remote_address: 'foobar'))).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => 'foobar,abc/32' }, Unleash::Context.new(remote_address: '192.168.1.0'))).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => 'foobar,abc/32' }, nil)).to be_falsey
-      expect(strategy.is_enabled?({ 'IPs' => 'foobar,abc/32' })).to be_falsey
-    end
-
-    it 'should be enabled for valid params even if other params are invalid' do
-      expect(strategy.is_enabled?({ 'IPs' => '192.168.x.y,127.0.0.1' }, Unleash::Context.new(remote_address: '127.0.0.1'))).to be_truthy
-    end
-  end
-end
diff --git a/spec/unleash/strategy/user_with_id_spec.rb b/spec/unleash/strategy/user_with_id_spec.rb
deleted file mode 100644
index 18e326a..0000000
--- a/spec/unleash/strategy/user_with_id_spec.rb
+++ /dev/null
@@ -1,61 +0,0 @@
-require "unleash/strategy/user_with_id"
-require "unleash/context"
-
-RSpec.describe Unleash::Strategy::UserWithId do
-  describe '#is_enabled?' do
-    let(:strategy) { Unleash::Strategy::UserWithId.new }
-
-    context 'with string params' do
-      let(:unleash_context) { Unleash::Context.new({ 'userId' => 'bob' }) }
-
-      it 'should be enabled with correct params' do
-        expect(strategy.is_enabled?({ 'userIds' => 'alice,bob,carol,dave' }, unleash_context)).to be_truthy
-
-        unleash_context2 = Unleash::Context.new
-        unleash_context2.user_id = 'alice'
-        expect(strategy.is_enabled?({ 'userIds' => 'alice,bob,carol,dave' }, unleash_context2)).to be_truthy
-      end
-
-      it 'should be enabled with correct can include spaces' do
-        expect(strategy.is_enabled?({ 'userIds' => ' alice ,bob,carol,dave' }, unleash_context)).to be_truthy
-      end
-
-      it 'should be disabled with false params' do
-        expect(strategy.is_enabled?({ 'userIds' => 'alice,dave' }, unleash_context)).to be_falsey
-      end
-
-      it 'should be disabled on invalid params' do
-        expect(strategy.is_enabled?({ 'userIds' => nil }, unleash_context)).to be_falsey
-        expect(strategy.is_enabled?({}, unleash_context)).to be_falsey
-        expect(strategy.is_enabled?('string', unleash_context)).to be_falsey
-        expect(strategy.is_enabled?(nil, unleash_context)).to be_falsey
-      end
-
-      it 'should be disabled on invalid contexts' do
-        expect(strategy.is_enabled?({ 'userIds' => 'alice,bob,carol,dave' }, Unleash::Context.new)).to be_falsey
-        expect(strategy.is_enabled?({ 'userIds' => 'alice,bob,carol,dave' }, nil)).to be_falsey
-        expect(strategy.is_enabled?({ 'userIds' => 'alice,bob,carol,dave' })).to be_falsey
-      end
-    end
-
-    context 'with int params' do
-      let(:user_id) { 123 }
-      let(:unleash_context) { Unleash::Context.new({ 'userId' => user_id }) }
-
-      it 'should be enabled with correct params' do
-        expect(strategy.is_enabled?({ 'userIds' => '1,2,123' }, unleash_context)).to be_truthy
-
-        unleash_context2 = Unleash::Context.new(user_id: 1)
-        expect(strategy.is_enabled?({ 'userIds' => '1,2,123' }, unleash_context2)).to be_truthy
-      end
-
-      it 'should be enabled with correct can include spaces' do
-        expect(strategy.is_enabled?({ 'userIds' => ' 1 ,2, 123 ,200 ' }, unleash_context)).to be_truthy
-      end
-
-      it 'should be disabled with false params' do
-        expect(strategy.is_enabled?({ 'userIds' => '1,2' }, unleash_context)).to be_falsey
-      end
-    end
-  end
-end
diff --git a/spec/unleash/strategy/util_spec.rb b/spec/unleash/strategy/util_spec.rb
deleted file mode 100644
index 234b160..0000000
--- a/spec/unleash/strategy/util_spec.rb
+++ /dev/null
@@ -1,10 +0,0 @@
-require "unleash/strategy/util"
-
-RSpec.describe Unleash::Strategy::Util do
-  describe '.get_normalized_number' do
-    it "returns correct values" do
-      expect(Unleash::Strategy::Util.get_normalized_number('123', 'gr1')).to eq(73)
-      expect(Unleash::Strategy::Util.get_normalized_number('999', 'groupX')).to eq(25)
-    end
-  end
-end
diff --git a/spec/unleash/toggle_fetcher_spec.rb b/spec/unleash/toggle_fetcher_spec.rb
index 3821051..97ae8cd 100644
--- a/spec/unleash/toggle_fetcher_spec.rb
+++ b/spec/unleash/toggle_fetcher_spec.rb
@@ -55,25 +55,24 @@ RSpec.describe Unleash::ToggleFetcher do
   end
 
   describe '#save!' do
-    context 'when toggle_cache generation fails' do
-      before do
-        allow(toggle_fetcher).to receive(:toggle_cache).and_raise(StandardError)
-      end
-
-      it 'swallows the error' do
-        expect { toggle_fetcher.save! }.not_to raise_error
-      end
-    end
-
     context 'when toggle_cache with content is saved' do
-      before do
-        toggle_fetcher.toggle_cache = { features: [] }
-      end
-
       it 'creates a file with toggle_cache in JSON' do
-        toggle_fetcher.save!
+        toggles = {
+          version: 2,
+          features: [
+            {
+              name: "Feature.A",
+              description: "Enabled toggle",
+              enabled: true,
+              strategies: [{
+                  "name": "default"
+              }]
+            },
+          ]
+        }
+        toggle_fetcher.save! toggles.to_json
         expect(File.exist?(Unleash.configuration.backup_file)).to eq(true)
-        expect(File.read(Unleash.configuration.backup_file)).to eq('{"features":[]}')
+        expect(File.read(Unleash.configuration.backup_file)).to eq('{"version":2,"features":[{"name":"Feature.A","description":"Enabled toggle","enabled":true,"strategies":[{"name":"default"}]}]}')
       end
     end
   end
@@ -83,47 +82,28 @@ RSpec.describe Unleash::ToggleFetcher do
       before do
         # manually create a stub cache on disk, so we can test that we read it correctly later.
         cache_creator = described_class.new
-        cache_creator.toggle_cache = { features: [] }
-        cache_creator.save!
-
-        WebMock.stub_request(:get, "http://toggle-fetcher-test-url/client/features").to_return(status: 500)
-      end
+        toggles = {
+          version: 2,
+          features: [
+            {
+              name: "Feature.A",
+              description: "Enabled toggle",
+              enabled: true,
+              strategies: [{
+                  "name": "default"
+              }]
+            },
+          ]
+        }
 
-      it 'reads the backup file for values' do
-        expect(toggle_fetcher.toggle_cache).to eq("features" => [])
-      end
-    end
+        cache_creator.save! toggles.to_json
 
-    context 'when backup file does not exist' do
-      before do
-        File.delete(Unleash.configuration.backup_file) if File.exist?(Unleash.configuration.backup_file)
         WebMock.stub_request(:get, "http://toggle-fetcher-test-url/client/features").to_return(status: 500)
       end
 
-      it 'returns an empty toggle_cache' do
-        expect(toggle_fetcher.toggle_cache).to eq(nil)
-      end
-    end
-
-    context 'segments are present' do
-      it 'loads a segement map correctly' do
-        expect(toggle_fetcher.toggle_cache["segments"].count).to eq 1
-      end
-    end
-
-    context 'segments are not present' do
-      before do
-        WebMock.stub_request(:get, "http://toggle-fetcher-test-url/client/features")
-          .to_return(status: 200,
-                     body: {
-                       "version": 1,
-                       "features": []
-                     }.to_json,
-                     headers: {})
-      end
-
-      it 'loads an empty segment map' do
-        expect(toggle_fetcher.toggle_cache["segments"].count).to eq 0
+      it 'reads the backup file for values' do
+        enabled = Unleash.engine.enabled?('Feature.A', {})
+        expect(enabled).to eq(true)
       end
     end
   end
